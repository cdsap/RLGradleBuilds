<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RL Experiment Dashboard</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%233182ce' stroke='%232c5aa0' stroke-width='3'/%3E%3Cpath d='M30 40h40v5H30z' fill='white'/%3E%3Cpath d='M30 50h40v5H30z' fill='white'/%3E%3Cpath d='M30 60h40v5H30z' fill='white'/%3E%3Ccircle cx='25' cy='42.5' r='3' fill='%2348bb78'/%3E%3Ccircle cx='25' cy='52.5' r='3' fill='%23ed8936'/%3E%3Ccircle cx='25' cy='62.5' r='3' fill='%23f56565'/%3E%3Ctext x='50' y='30' text-anchor='middle' font-family='Arial' font-size='12' font-weight='bold' fill='white'%3ERL%3C/text%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='45' fill='%233182ce' stroke='%232c5aa0' stroke-width='3'/%3E%3Cpath d='M30 40h40v5H30z' fill='white'/%3E%3Cpath d='M30 50h40v5H30z' fill='white'/%3E%3Cpath d='M30 60h40v5H30z' fill='white'/%3E%3Ccircle cx='25' cy='42.5' r='3' fill='%2348bb78'/%3E%3Ccircle cx='25' cy='52.5' r='3' fill='%23ed8936'/%3E%3Ccircle cx='25' cy='62.5' r='3' fill='%23f56565'/%3E%3Ctext x='50' y='30' text-anchor='middle' font-family='Arial' font-size='12' font-weight='bold' fill='white'%3ERL%3C/text%3E%3C/svg%3E">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="config.js"></script>
  <script>
    // Fix tooltip positioning for rotated labels
    Chart.defaults.interaction.mode = 'nearest';
    Chart.defaults.interaction.axis = 'x';
    Chart.defaults.plugins.tooltip.position = 'nearest';
    Chart.defaults.plugins.tooltip.followPointer = true;
    // Remove x-axis titles for all charts
    Chart.defaults.scales.x.title.display = false;
    // Hide x-axis labels by default
    Chart.defaults.scales.x.display = false;
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f8fafc;
      min-height: 100vh;
      color: #1a202c;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1400px;
      margin: 20px auto;
      background: white;
      padding: 40px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      border: 1px solid #e2e8f0;
    }
    h1 {
      color: #1a202c;
      text-align: center;
      margin-bottom: 40px;
      font-size: 2.5rem;
      font-weight: 700;
    }
    h2 {
      color: #2d3748;
      margin-bottom: 25px;
      font-size: 1.8rem;
      font-weight: 600;
      position: relative;
    }
    h2::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 0;
      width: 60px;
      height: 3px;
      background: #3182ce;
      border-radius: 2px;
    }
    .form-group {
      margin-bottom: 25px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.95rem;
    }
    input[type="text"] {
      width: 100%;
      padding: 16px 20px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-size: 16px;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.9);
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: white;
    }
    button {
      padding: 16px 32px;
      background: #3182ce;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-right: 15px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      background: #2c5aa0;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    

    button:disabled {
      background: #a0aec0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Improve tooltip positioning for rotated labels */
    .chart-container canvas {
      cursor: crosshair;
    }
    .status {
      margin-top: 25px;
      padding: 16px 24px;
      border-radius: 12px;
      text-align: center;
      font-weight: 500;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .status.success {
      background: #48bb78;
      color: white;
      border: none;
    }
    .status.error {
      background: #f56565;
      color: white;
      border: none;
    }
    .status.info {
      background: #4299e1;
      color: white;
      border: none;
    }
    
    /* Experiment Table Styles */
    .experiments-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 25px;
      background: white;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .experiments-table th,
    .experiments-table td {
      padding: 16px 20px;
      text-align: left;
      border-bottom: 1px solid #f1f5f9;
    }
    .experiments-table th {
      background: #3182ce;
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .experiments-table tr:hover {
      background: #f7fafc;
      transition: all 0.2s ease;
    }
    .status-badge {
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .status-running {
      background: #ed8936;
      color: white;
    }
    .status-completed {
      background: #48bb78;
      color: white;
    }
    .status-failed {
      background: #f56565;
      color: white;
    }
    .status-pending {
      background: #4299e1;
      color: white;
    }
    
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .metric-item {
      background: #f8f9fa;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      text-align: center;
    }
    .metric-label {
      font-weight: bold;
      color: #4a5568;
    }
    
    /* New Compact Layout Styles */
    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .chart-container {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .chart-title {
      font-size: 16px;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .performance-overview {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .variants-summary {
      margin-bottom: 20px;
    }
    
    .variants-summary h5 {
      margin: 0 0 15px 0;
      color: #374151;
      font-size: 16px;
      font-weight: 600;
    }
    
    .variants-table-container {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: white;
    }
    
    .variants-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .variants-table th {
      padding: 12px 8px;
      text-align: left;
      border-bottom: 2px solid #e2e8f0;
      font-size: 14px;
      font-weight: 600;
      background: #f8fafc;
      color: #374151;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .variants-table td {
      padding: 12px 8px;
      border-bottom: 1px solid #f1f5f9;
      font-size: 14px;
    }
    
    .variants-table tbody tr:hover {
      background: #f7fafc;
    }
    
    .variant-toggle {
      background: #3182ce;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .variant-toggle:hover {
      background: #2c5aa0;
      transform: translateY(-1px);
    }
    
    .variants-row {
      background: #f8fafc;
    }
    
    .variants-container {
      padding: 20px;
      background: #f8fafc;
      border-radius: 8px;
    }
    
    .rl-actions {
      background: #f8f9fa;
      padding: 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .refresh-btn {
      background-color: #28a745;
    }
    .refresh-btn:hover {
      background-color: #218838;
    }
    
    .loading {
      text-align: center;
      padding: 20px;
      color: #666;
    }
    
    .variant-toggle {
      background-color: #17a2b8;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .variant-toggle:hover {
      background-color: #138496;
    }
    
    .variants-container {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin: 10px 0;
    }
    
    .variants-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background: white;
      border-radius: 4px;
      overflow: hidden;
    }
    .variants-table th,
    .variants-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
      font-size: 12px;
    }
    .variants-table th {
      background-color: #6c757d;
      color: white;
      font-weight: bold;
    }
    .variants-table tr:hover {
      background-color: #f8f9fa;
    }
    
    .experiments-table {
      font-size: 14px;
    }
    
    .experiments-table th,
    .experiments-table td {
      padding: 8px 6px;
    }
    
    .action-cell {
      font-family: monospace;
      font-size: 13px;
      white-space: nowrap;
    }
    
    /* Pagination Styles */
    .pagination-container {
      margin-top: 20px;
      text-align: center;
    }
    
    .pagination-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 10px;
    }
    
    .pagination-controls button {
      padding: 8px 16px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .pagination-controls button:hover:not(:disabled) {
      background: #f5f5f5;
    }
    
    .pagination-controls button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .pagination-controls button:not(:disabled) {
      color: #007bff;
    }
    
    #page-info {
      font-weight: bold;
      color: #333;
    }
    
    .pagination-info {
      color: #666;
      font-size: 14px;
    }
    
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .stat-card {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
    }
    .stat-number {
      font-size: 2em;
      font-weight: bold;
      color: #007bff;
    }
    .stat-label {
      color: #666;
      margin-top: 5px;
    }
    
    /* Charts Container */
    .charts-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 25px;
      margin-top: 25px;
    }
    .chart-container {
      background: white;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border: 1px solid #e2e8f0;
      transition: all 0.2s ease;
      min-height: 400px;
    }
    
    .chart-container canvas {
      max-height: 500px !important;
    }
    .chart-container:hover {
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .chart-title {
      text-align: center;
      margin-bottom: 20px;
      color: #4a5568;
      font-weight: 600;
      font-size: 1.1rem;
    }
    
    .chart-note {
      text-align: center;
      margin-top: 10px;
      color: #666;
      font-size: 0.9rem;
      font-style: italic;
    }
    
    @media (max-width: 768px) {
      .charts-container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÄ RL Experiment Dashboard</h1>
    
    <!-- Introduction Header -->
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 12px; margin-bottom: 30px; box-shadow: 0 8px 25px rgba(0,0,0,0.15);">
      <h2 style="color: white; margin-bottom: 20px; font-size: 1.8rem;">About This Project</h2>
      <p style="margin-bottom: 15px; line-height: 1.6; font-size: 16px;">
        This is a Reinforcement Learning (RL) system that optimizes Gradle build configurations by learning from build performance data. 
        Each experiment runs multiple build iterations with different configurations, collecting performance metrics and using them to guide future exploration.
      </p>
      <p style="margin-bottom: 20px; line-height: 1.6; font-size: 16px;">
        The system is designed to work with GitHub Actions runners and integrates with Develocity for build analytics.
      </p>
      <p style="font-size: 14px; opacity: 0.9; margin-bottom: 15px;">
        üìñ <strong>Learn more:</strong> Read the full article about this project: 
        <a href="https://dev.to/cdsap/gradle-learning-day-reinforcement-learning-for-build-optimization-2oh7" 
           target="_blank" rel="noopener noreferrer" 
           style="color: #ffd700; text-decoration: underline; font-weight: 600;">
          Gradle Learning Day: Reinforcement Learning for Build Optimization
        </a>
      </p>
      <p style="font-size: 14px; opacity: 0.9;">
        üîó <strong>Source Code:</strong> View the complete implementation: 
        <a href="https://github.com/cdsap/RLGradleBuilds" 
           target="_blank" rel="noopener noreferrer" 
           style="color: #ffd700; text-decoration: underline; font-weight: 600;">
          GitHub Repository
        </a>
      </p>
    </div>
    
  </div>

  <div class="container">
    <h2>üìä All Experiments</h2>
    <div id="experiments-container">
      <div class="loading">Loading experiments...</div>
    </div>
    <div id="pagination-container" style="display: none;">
      <div class="pagination-controls">
        <button id="prev-page" onclick="previousPage()" disabled>‚Üê Previous</button>
        <span id="page-info">Page 1 of 1</span>
        <button id="next-page" onclick="nextPage()" disabled>Next ‚Üí</button>
      </div>
      <div class="pagination-info">
        <span id="showing-info">Showing 0-0 of 0 experiments</span>
      </div>
    </div>
  </div>

  <!-- Experiment Creation Form -->
  <div class="container">
    <h2>üöÄ Start New RL Experiment</h2>
    
    <div class="form-group">
      <label for="repository">Repository Name:</label>
      <input type="text" id="repository" placeholder="e.g., cdsap/ExperimentGradle8.9" required>
    </div>
    
    <div class="form-group">
      <label for="task">Gradle Task:</label>
      <input type="text" id="task" placeholder="e.g., :help, :build, :test" value=":help">
    </div>
    
    <div class="form-group">
      <label for="max-iterations">Max Iterations:</label>
      <input type="number" id="max-iterations" value="15" min="5" max="100" style="width: 100%; padding: 16px 20px; border: 2px solid #e2e8f0; border-radius: 12px; font-size: 16px; background: rgba(255, 255, 255, 0.9);" placeholder="Number of iterations (5-100)" onchange="updateGitHubIterations()">
      <small style="color: #666; font-size: 12px;">Default: 15 iterations</small>
    </div>
    
    <button id="run-btn" onclick="startExperiment()">Start RL Experiment</button>
    <button class="refresh-btn" onclick="loadAllExperiments()">üîÑ Refresh Experiments</button>
    
    <!-- Status/Error Message Display -->
    <div id="status" class="status" style="display: none; margin-top: 20px;"></div>
  </div>

  <script>
    // Global variables
    let allExperiments = [];
    let currentPage = 1;
    let experimentsPerPage = 10;
    let totalPages = 1;

    // Helper function to parse Firestore timestamps
    function parseFirestoreTimestamp(timestamp) {
      if (!timestamp) return new Date();
      
      // If it's a Firestore timestamp object with toDate method
      if (timestamp.toDate && typeof timestamp.toDate === 'function') {
        return timestamp.toDate();
      }
      
      // If it's a Firestore timestamp object with _seconds and _nanoseconds
      if (timestamp._seconds !== undefined) {
        return new Date(timestamp._seconds * 1000 + (timestamp._nanoseconds || 0) / 1000000);
      }
      
      // If it's a Firestore timestamp object with seconds and nanoseconds
      if (timestamp.seconds !== undefined) {
        return new Date(timestamp.seconds * 1000 + (timestamp.nanoseconds || 0) / 1000000);
      }
      
      // If it's already a Date object
      if (timestamp instanceof Date) {
        return timestamp;
      }
      
      // If it's a string or number, try to parse it
      try {
        return new Date(timestamp);
      } catch (error) {
        console.warn('Could not parse timestamp:', timestamp);
        return new Date();
      }
    }

    function toggleVariants(experimentId) {
      const variantsRow = document.getElementById(`variants-${experimentId}`);
      if (variantsRow) {
        const isVisible = variantsRow.style.display !== 'none';
        variantsRow.style.display = isVisible ? 'none' : 'table-row';
        
        // Update button text
        const button = event.target;
        if (button) {
          button.textContent = isVisible ? 
            `${variantsRow.querySelector('tbody').children.length} variants` : 
            'Hide variants';
        }
        
        // Create charts when showing variants
        if (!isVisible) {
          setTimeout(() => {
            createExperimentCharts(experimentId);
          }, 100);
        }
      }
    }

    function updateGitHubIterations() {
      // Function kept for compatibility but no longer updates UI
      // GitHub iterations are calculated internally by the system
      return;
    }
    

    
    // Initialize GitHub iterations display on page load
    document.addEventListener('DOMContentLoaded', function() {
      updateGitHubIterations();
      loadAllExperiments();
      checkExperimentsEnabled(); // Check if experiments are enabled
      // Removed auto-refresh - user must manually refresh
    });

    async function loadAllExperiments() {
      const container = document.getElementById('experiments-container');
      container.innerHTML = '<div class="loading">Loading experiments...</div>';
      
      try {
        const response = await fetch(`${window.APP_CONFIG.FIREBASE_FUNCTIONS_BASE_URL}/getAllExperiments`);
        
        if (!response.ok) {
          throw new Error(`Failed to load experiments: ${response.status}`);
        }
        
        const data = await response.json();
        allExperiments = data.experiments || [];
        
        renderExperimentsTable();
        
      } catch (error) {
        console.error('Error loading experiments:', error);
        container.innerHTML = `<div class="status error">Error loading experiments: ${error.message}</div>`;
      }
    }



    function renderExperimentsTable() {
      const container = document.getElementById('experiments-container');
      
      if (allExperiments.length === 0) {
        container.innerHTML = '<div class="loading">No experiments found</div>';
        return;
      }
      
      // Sort experiments by creation date (newest first)
      const sortedExperiments = [...allExperiments].sort((a, b) => {
        const dateA = parseFirestoreTimestamp(a.created_at);
        const dateB = parseFirestoreTimestamp(b.created_at);
        return dateB - dateA;
      });
      
      // Calculate pagination
      totalPages = Math.ceil(sortedExperiments.length / experimentsPerPage);
      currentPage = Math.min(currentPage, totalPages);
      currentPage = Math.max(currentPage, 1);
      
      // Get experiments for current page
      const startIndex = (currentPage - 1) * experimentsPerPage;
      const endIndex = startIndex + experimentsPerPage;
      const experimentsForPage = sortedExperiments.slice(startIndex, endIndex);
      
      let tableHtml = `
        <table class="experiments-table">
          <thead>
            <tr>
              <th>Results</th>
              <th>Experiment ID</th>
              <th>Repository</th>
              <th>Task</th>
              <th>Status</th>
              <th>Current Action</th>
              <th>Best Action</th>
              <th>Reward</th>
              <th>Show Results</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      experimentsForPage.forEach(exp => {
        const statusClass = `status-${exp.status || 'pending'}`;
        const createdDate = parseFirestoreTimestamp(exp.created_at);
        
        // Format current action - only show for running experiments
        const currentAction = (exp.status === 'running' && exp.rl_action) ? 
          `W${exp.rl_action.max_workers || 'N/A'} G${exp.rl_action.gradle_heap_gb || 'N/A'}g K${exp.rl_action.kotlin_heap_gb || 'N/A'}g` : 'N/A';
        
        // Format best action
        const bestAction = exp.best_action ? 
          `W${exp.best_action.max_workers || 'N/A'} G${exp.best_action.gradle_heap_gb || 'N/A'}g K${exp.best_action.kotlin_heap_gb || 'N/A'}g` : 'N/A';
        
        // Format variants count
        const variants = exp.variants || [];
        const variantsCount = variants.length;
        const resultsHtml = variantsCount > 0 ? 
          `<button onclick="toggleVariants('${exp.id}')" class="variant-toggle">${variantsCount} results</button>` : 
          'No results';
        
        // Format task
        const task = exp.task || 'N/A';
        
        // Add thumbnail image for completed experiments
        let thumbnailHtml = '';
        if (exp.status === 'completed') {
          thumbnailHtml = `
                         <img src="${window.APP_CONFIG.FIREBASE_HOSTING_URL}/experiment-results/${exp.id}.png" 
                 alt="Results for ${exp.id}"
                 style="width: 60px; height: 40px; object-fit: cover; border-radius: 4px; cursor: pointer;"
                 onclick="showExperimentImage('${exp.id}')"
                 onerror="this.style.display='none';"
                 title="Click to view full results"
            />
          `;
        } else {
          thumbnailHtml = '<span style="color: #ccc; font-size: 12px;">Pending</span>';
        }

        tableHtml += `
          <tr>
            <td style="text-align: center;">${thumbnailHtml}</td>
            <td><strong>${exp.id}</strong></td>
            <td>${exp.repository}</td>
            <td>${task}</td>
            <td><span class="status-badge ${statusClass}">${exp.status || 'pending'}</span></td>
            <td style="text-align: center; font-family: monospace;">${currentAction}</td>
            <td style="text-align: center; font-family: monospace;">${bestAction}</td>
            <td>${exp.reward !== undefined ? exp.reward.toFixed(2) : 'N/A'}</td>
            <td>${resultsHtml}</td>
          </tr>
        `;
        
        // Add variants details row if there are variants
        if (variantsCount > 0) {
          tableHtml += `
            <tr id="variants-${exp.id}" class="variants-row" style="display: none;">
              <td colspan="9">
                <div class="variants-container">
                  <h4>Variants for ${exp.id}</h4>
                  
                                    <!-- Experiment Status -->
                  <div class="experiment-status" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; font-size: 14px;">
                      <div><strong>Status:</strong> <span class="status-${exp.status}">${exp.status}</span></div>
                      <div><strong>Created:</strong> ${parseFirestoreTimestamp(exp.created_at).toLocaleString()}</div>
                    </div>
                  </div>
                  
                  <!-- Performance Charts for this experiment -->
                  <div class="charts-container" style="margin-bottom: 20px;">
                    <div class="chart-container" style="grid-column: 1 / -1;">
                      <div class="chart-title">Build Duration & Reward by Variant</div>
                      <canvas id="combinedChart-${exp.id}"></canvas>
                    </div>
                  </div>
                  
                  <!-- Compact Performance Overview -->
                  <div class="performance-overview" style="margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div class="chart-container">
                      <div class="chart-title">GC Performance Overview</div>
                      <canvas id="gcOverviewChart-${exp.id}"></canvas>
                    </div>
                    <div class="chart-container">
                      <div class="chart-title">Kotlin Compile vs Reward</div>
                      <canvas id="kotlinCompileChart-${exp.id}"></canvas>
                    </div>
                  </div>
                  
                  <!-- Performance Summary -->
                  <div class="variants-summary" style="margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                      <div style="padding: 12px; background: #f0f9ff; border-radius: 6px; border-left: 4px solid #0ea5e9;">
                        <div style="font-size: 12px; color: #0369a1; margin-bottom: 4px;">Best Reward</div>
                        <div style="font-size: 18px; font-weight: 600; color: #0c4a6e;">
                          ${Math.max(...variants.map(v => v.reward || 0)).toFixed(3)}
                        </div>
                      </div>
                      <div style="padding: 12px; background: #f0fdf4; border-radius: 6px; border-left: 4px solid #22c55e;">
                        <div style="font-size: 12px; color: #15803d; margin-bottom: 4px;">Fastest Build ‚úÖ</div>
                        <div style="font-size: 18px; font-weight: 600; color: #14532d;">
                          ${Math.min(...variants.map(v => v.metrics?.build_time || Infinity)).toLocaleString()}ms
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Compact Variants Table -->
                  <div class="variants-table-container" style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <div style="padding: 8px; background: #f0fdf4; border-radius: 4px; margin-bottom: 8px; font-size: 12px; color: #15803d;">
                      <strong>üí° Tip:</strong> The row with the highest reward is highlighted in soft green
                    </div>
                    <table class="variants-table" style="width: 100%; border-collapse: collapse;">
                      <thead style="position: sticky; top: 0; background: #f8fafc; z-index: 10;">
                        <tr>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Workers</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Gradle Heap</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Kotlin Heap</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Reward</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Build Time</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Kotlin Compile</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Gradle GC</th>
                          <th style="padding: 12px 8px; text-align: center; border-bottom: 2px solid #e2e8f0; font-size: 14px;">Kotlin GC</th>
                        </tr>
                      </thead>
                      <tbody>
          `;
          
          // Find the best action (highest reward)
          const maxReward = Math.max(...variants.map(v => v.reward || 0));
          
          variants.forEach(variant => {
            const isBestAction = variant.reward === maxReward;
            const rowStyle = isBestAction ? 'background-color: #f0fdf4;' : '';
            
            tableHtml += `
              <tr style="${rowStyle}">
                <td style="text-align: center; font-family: monospace;">${variant.rl_action?.max_workers || 'N/A'}</td>
                <td style="text-align: center; font-family: monospace;">${variant.rl_action?.gradle_heap_gb || 'N/A'}GB</td>
                <td style="text-align: center; font-family: monospace;">${variant.rl_action?.kotlin_heap_gb || 'N/A'}GB</td>
                <td style="text-align: center;">${variant.reward !== undefined ? variant.reward.toFixed(2) : 'N/A'}</td>
                <td style="text-align: center;">${variant.metrics?.build_time || 'N/A'}ms</td>
                <td style="text-align: center;">${variant.metrics?.kotlin_compile_duration || 'N/A'}ms</td>
                <td style="text-align: center;">${variant.metrics?.gradle_gc_time ? variant.metrics.gradle_gc_time.toFixed(2) + 's' : 'N/A'}</td>
                <td style="text-align: center;">${variant.metrics?.kotlin_gc_time ? variant.metrics.kotlin_gc_time.toFixed(2) + 's' : 'N/A'}</td>
              </tr>
            `;
          });
          
          tableHtml += `
                    </tbody>
                  </table>
                </div>
              </td>
            </tr>
          `;
        }
      });
      
      tableHtml += `
          </tbody>
        </table>
      `;
      
      container.innerHTML = tableHtml;
      
      // Update pagination controls
      updatePaginationControls();
    }

    function createExperimentCharts(experimentId) {
      const experiment = allExperiments.find(exp => exp.id === experimentId);
      console.log('Creating charts for experiment:', experimentId, experiment);
      
      if (!experiment) {
        console.log('Experiment not found');
        return;
      }
      
      if (!experiment.variants || experiment.variants.length === 0) {
        console.log('No variants found for experiment:', experimentId);
        return;
      }

      console.log('Variants found:', experiment.variants);
      
      // Filter variants that have metrics with build_time
      const variants = experiment.variants.filter(v => {
        console.log('Checking variant:', v);
        return v.metrics && v.metrics.build_time;
      });
      
      console.log('Filtered variants with build_time:', variants);
      
      if (variants.length === 0) {
        console.log('No variants with build_time found');
        return;
      }

      // Create combined chart (Build Duration & Reward)
      createCombinedChart(experimentId, variants);
      
      // Create GC overview chart (Gradle GC, Kotlin GC only)
      createGcOverviewChart(experimentId, variants);
      
      // Create Kotlin compile vs reward chart
      createKotlinCompileChart(experimentId, variants);
    }
    
    function updatePaginationControls() {
      const paginationContainer = document.getElementById('pagination-container');
      const prevButton = document.getElementById('prev-page');
      const nextButton = document.getElementById('next-page');
      const pageInfo = document.getElementById('page-info');
      const showingInfo = document.getElementById('showing-info');
      
      if (allExperiments.length === 0) {
        paginationContainer.style.display = 'none';
        return;
      }
      
      paginationContainer.style.display = 'block';
      
      // Update button states
      prevButton.disabled = currentPage <= 1;
      nextButton.disabled = currentPage >= totalPages;
      
      // Update page info
      pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      
      // Update showing info
      const startIndex = (currentPage - 1) * experimentsPerPage + 1;
      const endIndex = Math.min(currentPage * experimentsPerPage, allExperiments.length);
      showingInfo.textContent = `Showing ${startIndex}-${endIndex} of ${allExperiments.length} experiments`;
    }
    
    function previousPage() {
      if (currentPage > 1) {
        currentPage--;
        renderExperimentsTable();
      }
    }
    
    function nextPage() {
      if (currentPage < totalPages) {
        currentPage++;
        renderExperimentsTable();
      }
    }

    function createCombinedChart(experimentId, variants) {
      const ctx = document.getElementById(`combinedChart-${experimentId}`);
      if (!ctx) {
        console.log('Canvas element not found for combined chart');
        return;
      }

      console.log('Creating combined chart for experiment:', experimentId);

      // Destroy existing chart if it exists
      const existingChart = window[`combinedChart-${experimentId}`];
      if (existingChart && typeof existingChart.destroy === 'function') {
        existingChart.destroy();
      }

      const labels = variants.map(v => v.variant_id || v.iteration || 'Unknown');
      const buildTimes = variants.map(v => (v.metrics.build_time || 0) / 1000); // Convert to seconds
      const rewards = variants.map(v => v.reward || 0);

      // Find the winner (highest reward)
      const maxReward = Math.max(...rewards);
      const winnerIndex = rewards.indexOf(maxReward);

      console.log('Combined chart data:', { labels, buildTimes, rewards, winnerIndex, maxReward });

      window[`combinedChart-${experimentId}`] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Build Time (seconds)',
            data: buildTimes,
            backgroundColor: buildTimes.map((_, index) => 
              index === winnerIndex ? 'rgba(34, 197, 94, 0.8)' : 'rgba(54, 162, 235, 0.6)'
            ),
            borderColor: buildTimes.map((_, index) => 
              index === winnerIndex ? 'rgba(34, 197, 94, 1)' : 'rgba(54, 162, 235, 1)'
            ),
            borderWidth: 1,
            yAxisID: 'y'
          }, {
            label: 'Reward',
            data: rewards,
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1,
            type: 'line',
            yAxisID: 'y1'
          }]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                usePointStyle: true,
                padding: 20,
                font: {
                  size: 12
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const variant = variants[context.dataIndex];
                  if (context.dataset.label === 'Build Time (seconds)') {
                    const isWinner = context.dataIndex === winnerIndex;
                    return `Build Time: ${context.parsed.y.toFixed(1)}s${isWinner ? ' üèÜ' : ''}`;
                  } else if (context.dataset.label === 'Reward') {
                    return `Reward: ${context.parsed.y.toFixed(3)}`;
                  }
                  return `${context.dataset.label}: ${context.parsed.y}`;
                },
                afterBody: function(context) {
                  const variant = variants[context[0].dataIndex];
                  if (variant.rl_action) {
                    return [
                      '',
                      `Workers: ${variant.rl_action.max_workers || 'N/A'}`,
                      `Gradle Heap: ${variant.rl_action.gradle_heap_gb || 'N/A'}GB`,
                      `Kotlin Heap: ${variant.rl_action.kotlin_heap_gb || 'N/A'}GB`
                    ];
                  }
                  return [];
                }
              }
            }
          },
          scales: {
            x: {
              display: false,
              title: {
                display: false
              },
              ticks: {
                maxRotation: 15,
                minRotation: 0,
                autoSkip: true,
                maxTicksLimit: variants.length,
                callback: function(value, index, values) {
                  return this.getLabelForValue(value);
                }
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: false
              },
              beginAtZero: false,
              ticks: {
                callback: function(value, index, values) {
                  return value.toFixed(1) + 's';
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Reward'
              },
              beginAtZero: false,
              ticks: {
                callback: function(value, index, values) {
                  return value.toFixed(3);
                }
              },
              grid: {
                drawOnChartArea: false,
              },
            }
          }
        }
      });
    }

    function createGcOverviewChart(experimentId, variants) {
      const ctx = document.getElementById(`gcOverviewChart-${experimentId}`);
      if (!ctx) {
        console.log('Canvas element not found for GC overview chart');
        return;
      }

      console.log('Creating GC overview chart for experiment:', experimentId);

      // Destroy existing chart if it exists
      const existingChart = window[`gcOverviewChart-${experimentId}`];
      if (existingChart && typeof existingChart.destroy === 'function') {
        existingChart.destroy();
      }

      const labels = variants.map(v => v.variant_id || v.iteration || 'Unknown');
      const gradleGcTimes = variants.map(v => v.metrics?.gradle_gc_time || 0);
      const kotlinGcTimes = variants.map(v => v.metrics?.kotlin_gc_time || 0);
      const rewards = variants.map(v => v.reward || 0);

      console.log('GC overview chart data:', { labels, gradleGcTimes, kotlinGcTimes, rewards });

      window[`gcOverviewChart-${experimentId}`] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Gradle GC Time (seconds)',
            data: gradleGcTimes,
            backgroundColor: 'rgba(255, 159, 64, 0.6)',
            borderColor: 'rgba(255, 159, 64, 1)',
            borderWidth: 1,
            yAxisID: 'y'
          }, {
            label: 'Kotlin GC Time (seconds)',
            data: kotlinGcTimes,
            backgroundColor: 'rgba(153, 102, 255, 0.6)',
            borderColor: 'rgba(153, 102, 255, 1)',
            borderWidth: 1,
            yAxisID: 'y'
          }, {
            label: 'Reward',
            data: rewards,
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1,
            type: 'line',
            yAxisID: 'y1'
          }]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                usePointStyle: true,
                padding: 20,
                font: {
                  size: 12
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const variant = variants[context.dataIndex];
                  if (context.dataset.label === 'Reward') {
                    return `Reward: ${context.parsed.y.toFixed(3)}`;
                  } else {
                    return [
                      `Variant: ${variant.variant_id || variant.iteration || 'Unknown'}`,
                      `${context.dataset.label}: ${context.parsed.y.toFixed(2)}s`,
                      `Workers: ${variant.rl_action?.max_workers || 'N/A'}`,
                      `Gradle Heap: ${variant.rl_action?.gradle_heap_gb || 'N/A'}GB`,
                      `Kotlin Heap: ${variant.rl_action?.kotlin_heap_gb || 'N/A'}GB`,
                      `Reward: ${variant.reward?.toFixed(3) || 'N/A'}`
                    ];
                  }
                }
              }
            }
          },
          scales: {
            x: {
              display: false,
              title: {
                display: false
              },
              ticks: {
                maxRotation: 45,
                minRotation: 0,
                autoSkip: true,
                maxTicksLimit: variants.length,
                callback: function(value, index, values) {
                
                  return this.getLabelForValue(value);
                }
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Time (seconds)'
              },
              beginAtZero: false,
              ticks: {
                callback: function(value, index, values) {
                  return value.toFixed(2) + 's';
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Reward'
              },
              beginAtZero: false,
              ticks: {
                callback: function(value, index, values) {
                  return value.toFixed(3);
                }
              },
              grid: {
                drawOnChartArea: false,
              },
            }
          }
        }
      });
    }

    function createKotlinCompileChart(experimentId, variants) {
      const ctx = document.getElementById(`kotlinCompileChart-${experimentId}`);
      if (!ctx) {
        console.log('Canvas element not found for Kotlin Compile chart');
        return;
      }

      console.log('Creating Kotlin Compile chart for experiment:', experimentId);

      // Destroy existing chart if it exists
      const existingChart = window[`kotlinCompileChart-${experimentId}`];
      if (existingChart && typeof existingChart.destroy === 'function') {
        existingChart.destroy();
      }

      const labels = variants.map(v => v.variant_id || v.iteration || 'Unknown');
      const kotlinCompileTimes = variants.map(v => (v.metrics?.kotlin_compile_duration || 0) / 1000); // Convert to seconds
      const rewards = variants.map(v => v.reward || 0);

      console.log('Kotlin Compile chart data:', { labels, kotlinCompileTimes, rewards });

      window[`kotlinCompileChart-${experimentId}`] = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Kotlin Compile Time (seconds)',
            data: kotlinCompileTimes,
            backgroundColor: 'rgba(153, 102, 255, 0.6)',
            borderColor: 'rgba(153, 102, 255, 1)',
            borderWidth: 1,
            yAxisID: 'y'
          }, {
            label: 'Reward',
            data: rewards,
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: 'rgba(255, 99, 132, 1)',
            borderWidth: 1,
            type: 'line',
            yAxisID: 'y1'
          }]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                usePointStyle: true,
                padding: 20,
                font: {
                  size: 12
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const variant = variants[context.dataIndex];
                  if (context.dataset.label === 'Kotlin Compile Time (seconds)') {
                    return `Kotlin Compile: ${context.parsed.y.toFixed(2)}s`;
                  } else if (context.dataset.label === 'Reward') {
                    return `Reward: ${context.parsed.y.toFixed(3)}`;
                  }
                  return `${context.dataset.label}: ${context.parsed.y}`;
                },
                afterBody: function(context) {
                  const variant = variants[context[0].dataIndex];
                  if (variant.rl_action) {
                    return [
                      '',
                      `Workers: ${variant.rl_action.max_workers || 'N/A'}`,
                      `Gradle Heap: ${variant.rl_action.gradle_heap_gb || 'N/A'}GB`,
                      `Kotlin Heap: ${variant.rl_action.kotlin_heap_gb || 'N/A'}GB`
                    ];
                  }
                  return [];
                }
              }
            }
          },
          scales: {
            x: {
              display: false,
              title: {
                display: false
              },
              ticks: {
                maxRotation: 45,
                minRotation: 0,
                autoSkip: true,
                maxTicksLimit: variants.length,
                callback: function(value, index, values) {
                  return this.getLabelForValue(value);
                }
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Time (seconds)'
              },
              beginAtZero: false,
              ticks: {
                callback: function(value, index, values) {
                  return value.toFixed(2) + 's';
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Reward'
              },
              beginAtZero: false,
              ticks: {
                callback: function(value, index, values) {
                  return value.toFixed(3);
                }
              },
              grid: {
                drawOnChartArea: false,
              },
            }
          }
        }
      });
    }

    // Check if experiments are enabled
    async function checkExperimentsEnabled() {
      try {
        const response = await fetch(`${window.APP_CONFIG.FIREBASE_FUNCTIONS_BASE_URL}/checkExperimentsEnabled`);
        if (response.ok) {
          const data = await response.json();
          const button = document.getElementById('run-btn');
          const status = document.getElementById('status');
          
          if (!data.experiments_enabled) {
            button.disabled = true;
            button.textContent = 'Experiments Disabled';
            button.style.backgroundColor = '#6b7280';
            button.style.cursor = 'not-allowed';
            showStatus('üö´ Experiments are currently disabled. Please try again later. To request access or report issues, create a new issue at: https://github.com/cdsap/RLGradleBuilds/issues/new', 'error');
          } else {
            button.disabled = false;
            button.textContent = 'Start RL Experiment';
            button.style.backgroundColor = '';
            button.style.cursor = '';
            status.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error checking experiments status:', error);
      }
    }

    async function startExperiment() {
      const repository = document.getElementById('repository').value.trim();
      const task = document.getElementById('task').value.trim();
      const selectionMethod = 'qtable'; // Always use Q-table based selection
      const maxIterations = document.getElementById('max-iterations').value;
      const button = document.getElementById('run-btn');
      const status = document.getElementById('status');
      
      if (!repository) {
        showStatus('Please enter a repository name', 'error');
        return;
      }
      
      if (!task) {
        showStatus('Please enter a Gradle task', 'error');
        return;
      }
      
      // Check if experiments are enabled before proceeding
      try {
        const enabledResponse = await fetch(`${window.APP_CONFIG.FIREBASE_FUNCTIONS_BASE_URL}/checkExperimentsEnabled`);
        if (enabledResponse.ok) {
          const enabledData = await enabledResponse.json();
          if (!enabledData.experiments_enabled) {
            showStatus('üö´ Experiments are currently disabled. Please try again later. To request access or report issues, create a new issue at: https://github.com/cdsap/RLGradleBuilds/issues/new', 'error');
            return;
          }
        }
      } catch (error) {
        console.error('Error checking experiments status:', error);
        showStatus('Error checking experiments status', 'error');
        return;
      }
      
      // Disable button and show loading
      button.disabled = true;
      button.textContent = 'Starting Experiment...';
      showStatus('Initializing RL experiment...', 'info');
      
      try {
        // Get action from RL agent using configuration
                 const rlResponse = await fetch(`${window.APP_CONFIG.RL_AGENT_URL}/get-action`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            experiment_id: `experiment-${Date.now()}`,
            max_iterations: parseInt(maxIterations) || 15 // Use default if not provided or invalid
          })
        });
        
        if (!rlResponse.ok) {
          throw new Error('Failed to get RL action');
        }
        
        const rlData = await rlResponse.json();
        showStatus('RL agent configured. Triggering experiment...', 'info');
        
        // Trigger experiment using configuration
                 const res = await fetch(`${window.APP_CONFIG.TRIGGER_EXPERIMENT_URL}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            repository: repository,
            task: task,
            selection_method: selectionMethod,
            max_iterations: parseInt(maxIterations) || 15 // Use default if not provided or invalid
          })
        });
        
        if (res.ok) {
          const data = await res.json();
          showStatus(`Experiment started successfully! ${data.message || ''}`, 'success');
          
          // Refresh the experiments list
          setTimeout(loadAllExperiments, 2000);
        } else {
          const errorData = await res.json();
          if (res.status === 409) {
            // Concurrent experiment error - show more detailed message
            const existingId = errorData.existingExperimentId;
            const existingStatus = errorData.existingStatus;
            showStatus(`‚è≥ Another experiment is currently running (${existingId}, status: ${existingStatus}). Please wait for it to complete before starting a new one.`, 'error');
            
            // Highlight the running experiment in the table
            setTimeout(() => {
              loadAllExperiments();
              highlightRunningExperiment(existingId);
            }, 1000);
          } else {
            showStatus(`Error: ${errorData.error || 'Failed to trigger experiment'}`, 'error');
          }
        }
        
      } catch (error) {
        console.error('Error:', error);
        showStatus(`Error: ${error.message}`, 'error');
      } finally {
        // Re-enable button
        button.disabled = false;
        button.textContent = 'Start RL Experiment';
      }
    }
    
    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = `status ${type}`;
      status.style.display = 'block';
    }
    
    function highlightRunningExperiment(experimentId) {
      // Find the experiment row and highlight it
      const rows = document.querySelectorAll('.experiments-table tbody tr');
      rows.forEach(row => {
        const firstCell = row.querySelector('td');
        if (firstCell && firstCell.textContent.includes(experimentId)) {
          row.style.backgroundColor = '#fff3cd';
          row.style.borderLeft = '4px solid #ffc107';
          row.style.transition = 'all 0.3s ease';
          
          // Remove highlight after 5 seconds
          setTimeout(() => {
            row.style.backgroundColor = '';
            row.style.borderLeft = '';
          }, 5000);
        }
      });
    }
    
    // Allow Enter key to submit
    document.getElementById('repository').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        startExperiment();
      }
    });
    


    function showExperimentImage(experimentId) {
      // Create modal to show full image
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        cursor: pointer;
      `;
      
      const img = document.createElement('img');
             img.src = `${window.APP_CONFIG.FIREBASE_HOSTING_URL}/experiment-results/${experimentId}.png`;
      img.style.cssText = `
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      `;
      
      modal.appendChild(img);
      document.body.appendChild(modal);
      
      // Close modal on click
      modal.onclick = () => {
        document.body.removeChild(modal);
      };
    }
    

  </script>
</body>
</html>